module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led[8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    .rst(rst){
      counter segment_counter(#SIZE(2), #DIV(10));
      counter slowclock(#SIZE(1), #DIV(26));
      counter medclock(#SIZE(1), #DIV(25));
    }
  }
  
  // seq_plus_vary seqplusvary(.clk(slowclock.value), .rst(rst));
  // segment_test segment_tester(.clk(slowclock.value), .rst(rst));
  sig write_a[16];
  sig a_value[16];
  sig write_b[16];
  sig b_value[16];
  sig write_enable;
  
  dff_b16 reg_a(
    .clk(medclock.value), .rst(rst), .write_val(write_a), 
    .write_enable(b1)
  );
  dff_b16 reg_b(
    .clk(medclock.value), .rst(rst), .write_val(write_b), 
    .write_enable(b1)
  );
  
  adder_b16 adder;
  multi_segment segment_display(.clk(clk), .rst(rst));
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    a_value = reg_a.out;
    adder.x = reg_a.out;
    adder.y = 16h0001;
    adder.subtract = b1;
    write_a = adder.s;
    
    io_led[0] = adder.s[7:0];
    io_led[1] = adder.s[15:8];
    segment_display.number = adder.s;
    io_sel = 4b1111; // don't select any 7-segs by default
    io_seg = 8hFF; // blank the target 7-seg by default
    
    case (segment_counter.value) {
      2b00:
        io_sel = 4b1110;
        io_seg = segment_display.seg_out1;
      2b01:
        io_sel = 4b1101;
        io_seg = segment_display.seg_out2;
      2b10:
        io_sel = 4b1011;
        io_seg = segment_display.seg_out3;
      2b11:
        io_sel = 4b0111;
        io_seg = segment_display.seg_out4;
    }
    
    usb_tx = usb_rx;        // loop serial port
    led = 8hAA;             // turn LEDs off
    
    // io_led = 3x{{8h00}};    // turn LEDs off
    // io_seg = 8b10100100;
    // io_sel = 4b1110; // select first digit
  }
}