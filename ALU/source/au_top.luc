module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led[8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    button_conditioner btn_cond;
    // edge_detector edge (#RISE(1), #FALL(0));
    
    .rst(rst) {
      counter segment_counter(#SIZE(2), #DIV(10));
      counter slowclock(#SIZE(1), #DIV(26));
      counter medclock(#SIZE(1), #DIV(20));
    }
  }
  
  // seq_plus_vary seqplusvary(.clk(slowclock.value), .rst(rst));
  // segment_test segment_tester(.clk(slowclock.value), .rst(rst));
  sig a_value[16];
  sig b_value[16];  
  
  var display_number[16];
  var display_select[2];
  
  register reg_a(
    #SIZE(16), .clk(medclock.value), .rst(rst), .write_enable(b1)
  );
  register reg_b(
    #SIZE(16), .clk(medclock.value), .rst(rst), .write_enable(b1)
  );
  register alufn(
    #SIZE(6), .clk(medclock.value), .rst(rst), .write_enable(b1)
  );
  
  multi_segment segment_display(.clk(clk), .rst(rst));
  adder_b16 adder_unit;
  
  always {
    btn_cond.in = io_button[4];
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out | btn_cond.out;   // conditioned reset
    // next values of reg_a, reg_b, and alufn are current values by default
    reg_a.write_val = reg_a.out;
    reg_b.write_val = reg_b.out;
    alufn.write_val = alufn.out;

    a_value = reg_a.out;
    
    // assign 3 arrays of 8 bits of zeros to io_leds
    // i.e. turn off all the leds by default
    io_led = 3x{{8h0000}};
    display_number = 16h0000;
    display_select = io_dip[2][7:6];
    adder_unit.x = display_number;
    adder_unit.y = 16h0000;
    adder_unit.subtract = b1;
    
    if (io_dip[2][0] == b1) {
      adder_unit.y = 16h0001;
    }
    
    case (display_select) {
      2b00: 
        display_number = reg_a.out;
        reg_a.write_val = adder_unit.s;
      2b01: 
        display_number = reg_b.out;
        reg_b.write_val = adder_unit.s;
      2b10: 
        display_number = alufn.out;
        alufn.write_val = adder_unit.s;
    }
        
    segment_display.number = display_number;
    io_sel = 4b1111; // don't select any 7-segs by default
    io_seg = 8hFF; // blank the target 7-seg by default
    
    case (segment_counter.value) {
      2b00:
        io_sel = 4b1110;
        io_seg = segment_display.seg_out1;
      2b01:
        io_sel = 4b1101;
        io_seg = segment_display.seg_out2;
      2b10:
        io_sel = 4b1011;
        io_seg = segment_display.seg_out3;
      2b11:
        io_sel = 4b0111;
        io_seg = segment_display.seg_out4;
    }
    
    usb_tx = usb_rx;        // loop serial port
    led = 8hAA;             // turn LEDs off
    
    // io_led = 3x{{8h00}};    // turn LEDs off
    // io_seg = 8b10100100;
    // io_sel = 4b1110; // select first digit
  }
}