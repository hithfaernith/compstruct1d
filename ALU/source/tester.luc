module tester (
    input clk,  // clock
    input rst,  // reset
    input restart_tests,
    
    input select_data[2],
    input manual_data_input[16],
    input write_enable,
    input pause,
    
    output state_display[8], // shows which test case is currently running
    output data_display[16], // shows either a, b, alufn or alu output, depending on select signal
    output error_is_happening,
    
    output z,
    output v,
    output n
  ) {
  
  .clk(clk) {
    .rst(rst) {
      
      // Because we wish to be able to pause the tester, manually alter one value,
      // and then remember the new value while viewing/altering the others, we need
      // registers to store our values of a, b and alufn.
      dff current_a[16];
      dff current_b[16];
      dff current_alufn[6];
      
      // This is a clock that can be paused from ticking with an input.
      pausable_slow_clock psc(.pause(pause));
      
    }
  }
  
  sig a[16], b[16], alufn[6], final_alu_out[16], ans[16];
  
  // Note that the input to the alu is through the registers. Since all
  // registers run on the extremely fast main clock, any delay in
  // propagating appropriate values for that state to the alu is negligible
  alu_full alu(.a(current_a.q), .b(current_b.q), .alufn(current_alufn.q));
  
  // Easy-to-recognize pattern shows up on the LED to indicate the whole
  // run of tests has been successfully concluded.
  const SUCCESS_SIGNAL = 8hAA;
  
  const ALWAYS_WRONG = 16hDEAD;
  
  .clk(psc.value) {
    .rst(rst) {
      // Each state represents a test case, except for SUCCESS. Since we take
      // advantage of the fact that Alchitry assigns incremental numbers to states
      // in order of declaration, the order of declaration here will determine
      // the order of tests when running.
      fsm state = {
        ADD,
        ADD_OVERFLOW,
        SUBTRACT,
        SUBTRACT_UNDERFLOW,
        MULTIPLY,
        MULTIPLY_OVERFLOW,
        MULTIPLY_UNDERFLOW,
        DIVIDE_WHOLE,
        DIVIDE_FRACTIONAL,
        DIVIDE_BY_ZERO,
        REVERSE,
        REVERSE_ALL,
        AND,
        OR,
        XOR,
        A,
        LEFT_SHIFT,
        RIGHT_SHIFT,
        LEFT_ARITH_SHIFT,
        RIGHT_ARITH_SHIFT,
        LEFT_ROTATE,
        RIGHT_ROTATE,
        COMPARE_EQ_WHEN_EQ,
        COMPARE_EQ_WHEN_LT,
        COMPARE_EQ_WHEN_GT,
        COMPARE_LT_WHEN_EQ,
        COMPARE_LT_WHEN_LT,
        COMPARE_LT_WHEN_GT,
        COMPARE_LTE_WHEN_EQ,
        COMPARE_LTE_WHEN_LT,
        COMPARE_LTE_WHEN_GT,
        SUCCESS // important to declare SUCCESS at the end, since we only want to stop after
                // all other test cases have been run.
      };
    }
  }
  
  always {
    // Long series of hardcoded test cases by assigning values to a, b, alufn and ans
    // depending on the state
    case(state.q){
      state.ADD:
        a = 1;
        b = 1;
        alufn = 6b000000;
        ans = 2;
      
      state.ADD_OVERFLOW:
        a = 32767;
        b = 1;
        alufn = 6b000000;
        ans = -32768;
      
      state.SUBTRACT:
        a = 5;
        b = 3;
        alufn = 6b000001;
        ans = 2;
      
      state.SUBTRACT_UNDERFLOW:
        a = -32768;
        b = 1;
        alufn = 6b000001;
        ans = 32767;
      
      state.MULTIPLY:
        a = 1;
        b = 2;
        alufn = 6b000010;
        ans = 2;
      
      state.MULTIPLY_OVERFLOW:
        a = 8192;
        b = 4;
        alufn = 6b000010;
        ans = -32768;
      
      state.MULTIPLY_UNDERFLOW:
        a = -8193;
        b = 4;
        alufn = 6b000010;
        ans = 32764;
      
      state.DIVIDE_WHOLE:
        a = 8;
        b = 2;
        alufn = 6b000011;
        ans = 4;
      
      state.DIVIDE_FRACTIONAL:
        a = 9;
        b = 2;
        alufn = 6b000011;
        ans = 4;
      
      state.DIVIDE_BY_ZERO:
        a = 8;
        b = 0;
        alufn = 6b000011;
        ans = -1;
      
      state.REVERSE:
        a = 16hFF00;
        b = 16h0002;
        alufn = 6b001000;
        ans = 16b1101111100000100;
      
      state.REVERSE_ALL:
        a = 16b1010101111001101;
        b = 0;
        alufn = 6b001001;
        ans = 16b1011001111010101;
      
      state.AND:
        a = 16hFF00;
        b = 16hAAAA;
        alufn = 6b011000;
        ans = 16hAA00;
      
      state.OR:
        a = 16hFF00;
        b = 16hAAAA;
        alufn = 6b011110;
        ans = 16hFFAA;
      
      state.XOR:
        a = 16hFF00;
        b = 16hAAAA;
        alufn = 6b010110;
        ans = 16h55AA;
      
      state.A:
        a = 16hFF00;
        b = 16hAAAA;
        alufn = 6b011100;
        ans = 16hFF00;
      
      state.LEFT_SHIFT:
        a = 16b1111001111001111;
        b = 16h0002;
        alufn = 6b100000;
        ans = 16b1100111100111100;
      
      state.RIGHT_SHIFT:
        a = 16b1111001111001111;
        b = 16h0002;
        alufn = 6b100001;
        ans = 16b0011110011110011;
      
      state.LEFT_ARITH_SHIFT:
        a = 16b1111001111001111;
        b = 16h0002;
        alufn = 6b100010;
        ans = 16b1100111100111100;
      
      state.RIGHT_ARITH_SHIFT:
        a = 16b1111001111001111;
        b = 16h0002;
        alufn = 6b100011;
        ans = 16b1111110011110011;
      
      state.LEFT_ROTATE:
        a = 16b0101010000000000;
        b = 16h0004;
        alufn = 6b100100;
        ans = 16b0100000000000101;
      
      state.RIGHT_ROTATE:
        a = 16b0000000000101010;
        b = 16h0004;
        alufn = 6b100101;
        ans = 16b1010000000000010;
      
      state.COMPARE_EQ_WHEN_EQ:
        a = 1;
        b = 1;
        alufn = 6b110011;
        ans = 1;
      
      state.COMPARE_EQ_WHEN_LT:
        a = 1;
        b = 2;
        alufn = 6b110011;
        ans = 0;
      
      state.COMPARE_EQ_WHEN_GT:
        a = 2;
        b = 1;
        alufn = 6b110011;
        ans = 0;
      
      state.COMPARE_LT_WHEN_EQ:
        a = 1;
        b = 1;
        alufn = 6b110101;
        ans = 0;
      
      state.COMPARE_LT_WHEN_LT:
        a = 1;
        b = 2;
        alufn = 6b110101;
        ans = 1;
      
      state.COMPARE_LT_WHEN_GT:
        a = 2;
        b = 1;
        alufn = 6b110101;
        ans = 0;
      
      state.COMPARE_LTE_WHEN_EQ:
        a = 1;
        b = 1;
        alufn = 6b110111;
        ans = 1;
      
      state.COMPARE_LTE_WHEN_LT:
        a = 1;
        b = 2;
        alufn = 6b110111;
        ans = 1;
      
      state.COMPARE_LTE_WHEN_GT:
        a = 2;
        b = 1;
        alufn = 6b110111;
        ans = 0;
      
      // The only state this default should apply to is SUCCESS.
      default:
        a = 0;
        b = 0;
        alufn = 0;
        
        // We wish to standardize that the error signal shows up
        // when SUCCESS occurs (or any non-test-case state, if any
        // states may be added in the future)
        ans = ALWAYS_WRONG;
    }
    
    // Recall that the inputs of the ALU are attached to these registers,
    // not the a, b and alufn signals themselves
    if (~pause) {
      current_a.d = a;
      current_b.d = b;
      current_alufn.d = alufn;
    }
    
    
    if (state.q == state.SUCCESS)
      // If we are at SUCCESS, simply stay in that state
      state.d = state.q;
    else
      // Otherwise, move on to next test case. Recall that Alchitry assigns
      // incremental numbers to states in order of declaration.
      state.d = state.q + 1;
    
    
    final_alu_out = alu.out;
    if (write_enable) {
      case (select_data) {
        2b00:
          final_alu_out = alu.out ^ manual_data_input; // for manually corrupting individual bits
        2b01:
          current_b.d = manual_data_input;
        2b10:
          current_a.d = manual_data_input;
        2b11:
          current_alufn.d = manual_data_input[5:0];
      }
    }
    
    
    if (final_alu_out == ans) {
      error_is_happening = 0;
    } else {
      error_is_happening = 1;
    }
    
    
    
    if (state.q == state.SUCCESS)
      state_display = SUCCESS_SIGNAL;
    else
      state_display = state.q;
    
    if (restart_tests)
      state.d = 0;
    
    // Choose what to view on the 7-segment display and the LED array
    data_display = 0;
    case (select_data) {
      2b00:
        data_display = final_alu_out;
      2b01:
        data_display = current_b.q;
      2b10:
        data_display = current_a.q;
      2b11:
        data_display = current_alufn.q;
    }
    
    // simply pass through z, v and n signals for display on the board
    z = alu.z;
    v = alu.v;
    n = alu.n;
  }
}