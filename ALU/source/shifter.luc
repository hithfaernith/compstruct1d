module shifter (
    input number[16],
    input bits[4],
    input shift_type[3],
    output out[16]
  ) {
  
  const LEFT_SHIFT = 3b000;
  const RIGHT_SHIFT = 3b001;
  const LEFT_ARITH_SHIFT = 3b010;
  const RIGHT_ARITH_SHIFT = 3b011;
  
  const LEFT_ROTATE = 3b100;
  const RIGHT_ROTATE = 3b101;
  
  always {
    out = number;
    case (shift_type) {
      LEFT_SHIFT:
        out = number << bits;
      RIGHT_SHIFT:
        out = number >> bits;
      LEFT_ARITH_SHIFT:
        out = $signed(number) <<< bits;
      RIGHT_ARITH_SHIFT:
        out = $signed(number) >>> bits;
      LEFT_ROTATE:
        out = (number << bits)|(number >> (16 - bits));
      RIGHT_ROTATE:
        out = (number >> bits)|(number << (16 - bits));
      }
    }
  }


        /**
         * their '>>>' operator doesnt seem to work as expected,
         * so we do this the old-fashioned way. '= 16hFFFF' for
         * every case might be more efficient depending on the
         * compiler's optimizations but it involes truncation so
         * ehh nvm
         */
/*
            1: out[15:14] = 2b11;
            2: out[15:13] = 3b111;
            3: out[15:12] = 4b1111;
            4: out[15:11] = 5b11111;
            5: out[15:10] = 6b111111;
            6: out[15:9] = 7b1111111;
            7: out[15:8] = 8b11111111;
            8: out[15:7] = 9b111111111;
            9: out[15:6] = 10b1111111111;
            10: out[15:5] = 11b11111111111;
            11: out[15:4] = 12b111111111111;
            12: out[15:3] = 13b1111111111111;
            13: out[15:2] = 14b11111111111111;
            14: out[15:1] = 15b111111111111111;
            15: out[15:0] = 16b1111111111111111;*/

