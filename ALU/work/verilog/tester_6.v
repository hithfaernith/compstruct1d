/*
   This file was generated automatically by Alchitry Labs version 1.2.7.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module tester_6 (
    input clk,
    input rst,
    input man_reset,
    input [1:0] select,
    input [15:0] man_input,
    input write_enable,
    input pause,
    output reg [7:0] out,
    output reg [15:0] display,
    output reg error_is_happening
  );
  
  
  
  reg [15:0] M_prev_a_d, M_prev_a_q = 1'h0;
  reg [15:0] M_prev_b_d, M_prev_b_q = 1'h0;
  reg [5:0] M_prev_alufn_d, M_prev_alufn_q = 1'h0;
  reg [15:0] M_prev_alu_out_d, M_prev_alu_out_q = 1'h0;
  reg [15:0] M_saved_ans_d, M_saved_ans_q = 1'h0;
  reg [7:0] M_saved_state_d, M_saved_state_q = 1'h0;
  wire [1-1:0] M_slowclock_value;
  counter_11 slowclock (
    .clk(clk),
    .rst(rst),
    .value(M_slowclock_value)
  );
  
  reg [15:0] a;
  reg [15:0] b;
  reg [5:0] alufn;
  
  wire [16-1:0] M_alu_out;
  alu_full_9 alu (
    .a(a),
    .b(b),
    .alufn(alufn),
    .out(M_alu_out)
  );
  
  reg [15:0] final_alu_out;
  reg [15:0] ans;
  
  localparam MAX_NEGATIVE = 8'h80;
  
  localparam SUCCESS_SIGNAL = 8'haa;
  
  localparam ADD_state = 5'd0;
  localparam ADD_OVERFLOW_state = 5'd1;
  localparam SUBTRACT_state = 5'd2;
  localparam SUBTRACT_UNDERFLOW_state = 5'd3;
  localparam MULTIPLY_state = 5'd4;
  localparam MULTIPLY_OVERFLOW_state = 5'd5;
  localparam MULTIPLY_UNDERFLOW_state = 5'd6;
  localparam DIVIDE_WHOLE_state = 5'd7;
  localparam DIVIDE_FRACTIONAL_state = 5'd8;
  localparam DIVIDE_BY_ZERO_state = 5'd9;
  localparam AND_state = 5'd10;
  localparam OR_state = 5'd11;
  localparam XOR_state = 5'd12;
  localparam A_state = 5'd13;
  localparam LEFT_SHIFT_state = 5'd14;
  localparam RIGHT_SHIFT_state = 5'd15;
  localparam LEFT_ARITH_SHIFT_state = 5'd16;
  localparam RIGHT_ARITH_SHIFT_state = 5'd17;
  localparam COMPARE_EQ_WHEN_EQ_state = 5'd18;
  localparam COMPARE_EQ_WHEN_LT_state = 5'd19;
  localparam COMPARE_EQ_WHEN_GT_state = 5'd20;
  localparam COMPARE_LT_WHEN_EQ_state = 5'd21;
  localparam COMPARE_LT_WHEN_LT_state = 5'd22;
  localparam COMPARE_LT_WHEN_GT_state = 5'd23;
  localparam COMPARE_LTE_WHEN_EQ_state = 5'd24;
  localparam COMPARE_LTE_WHEN_LT_state = 5'd25;
  localparam COMPARE_LTE_WHEN_GT_state = 5'd26;
  localparam SUCCESS_state = 5'd27;
  localparam PAUSE_AND_ENABLE_MANUAL_INPUT_state = 5'd28;
  
  reg [4:0] M_state_d, M_state_q = ADD_state;
  
  always @* begin
    M_state_d = M_state_q;
    M_prev_a_d = M_prev_a_q;
    M_prev_alufn_d = M_prev_alufn_q;
    M_saved_state_d = M_saved_state_q;
    M_prev_b_d = M_prev_b_q;
    M_prev_alu_out_d = M_prev_alu_out_q;
    M_saved_ans_d = M_saved_ans_q;
    
    final_alu_out = 1'h0;
    
    case (M_state_q)
      ADD_state: begin
        a = 1'h1;
        b = 1'h1;
        alufn = 6'h00;
        ans = 2'h2;
      end
      ADD_OVERFLOW_state: begin
        a = 15'h7fff;
        b = 1'h1;
        alufn = 6'h00;
        ans = $signed(17'h18000);
      end
      SUBTRACT_state: begin
        a = 3'h5;
        b = 2'h3;
        alufn = 6'h01;
        ans = 2'h2;
      end
      SUBTRACT_UNDERFLOW_state: begin
        a = $signed(17'h18000);
        b = 1'h1;
        alufn = 6'h01;
        ans = 15'h7fff;
      end
      MULTIPLY_state: begin
        a = 1'h1;
        b = 2'h2;
        alufn = 6'h02;
        ans = 2'h2;
      end
      MULTIPLY_OVERFLOW_state: begin
        a = 14'h2000;
        b = 3'h4;
        alufn = 6'h02;
        ans = $signed(17'h18000);
      end
      MULTIPLY_UNDERFLOW_state: begin
        a = $signed(15'h5fff);
        b = 3'h4;
        alufn = 6'h02;
        ans = 15'h7ffc;
      end
      DIVIDE_WHOLE_state: begin
        a = 4'h8;
        b = 2'h2;
        alufn = 6'h03;
        ans = 3'h4;
      end
      DIVIDE_FRACTIONAL_state: begin
        a = 4'h9;
        b = 2'h2;
        alufn = 6'h03;
        ans = 3'h4;
      end
      DIVIDE_BY_ZERO_state: begin
        a = 4'h8;
        b = 1'h0;
        alufn = 6'h03;
        ans = $signed(2'h3);
      end
      AND_state: begin
        a = 16'hff00;
        b = 16'haaaa;
        alufn = 6'h18;
        ans = 16'haa00;
      end
      OR_state: begin
        a = 16'hff00;
        b = 16'haaaa;
        alufn = 6'h1e;
        ans = 16'hffaa;
      end
      XOR_state: begin
        a = 16'hff00;
        b = 16'haaaa;
        alufn = 6'h16;
        ans = 16'h55aa;
      end
      A_state: begin
        a = 16'hff00;
        b = 16'haaaa;
        alufn = 6'h1a;
        ans = 16'hff00;
      end
      LEFT_SHIFT_state: begin
        a = 16'hf3cf;
        b = 16'h0002;
        alufn = 6'h20;
        ans = 16'hcf3c;
      end
      RIGHT_SHIFT_state: begin
        a = 16'hf3cf;
        b = 16'h0002;
        alufn = 6'h21;
        ans = 16'h3cf3;
      end
      LEFT_ARITH_SHIFT_state: begin
        a = 16'hf3cf;
        b = 16'h0002;
        alufn = 6'h22;
        ans = 16'hcf3c;
      end
      RIGHT_ARITH_SHIFT_state: begin
        a = 16'hf3cf;
        b = 16'h0002;
        alufn = 6'h23;
        ans = 16'hfcf3;
      end
      COMPARE_EQ_WHEN_EQ_state: begin
        a = 1'h1;
        b = 1'h1;
        alufn = 6'h33;
        ans = 1'h1;
      end
      COMPARE_EQ_WHEN_LT_state: begin
        a = 1'h1;
        b = 2'h2;
        alufn = 6'h33;
        ans = 1'h0;
      end
      COMPARE_EQ_WHEN_GT_state: begin
        a = 2'h2;
        b = 1'h1;
        alufn = 6'h33;
        ans = 1'h0;
      end
      COMPARE_LT_WHEN_EQ_state: begin
        a = 1'h1;
        b = 1'h1;
        alufn = 6'h35;
        ans = 1'h0;
      end
      COMPARE_LT_WHEN_LT_state: begin
        a = 1'h1;
        b = 2'h2;
        alufn = 6'h35;
        ans = 1'h1;
      end
      COMPARE_LT_WHEN_GT_state: begin
        a = 2'h2;
        b = 1'h1;
        alufn = 6'h35;
        ans = 1'h0;
      end
      COMPARE_LTE_WHEN_EQ_state: begin
        a = 1'h1;
        b = 1'h1;
        alufn = 6'h37;
        ans = 1'h1;
      end
      COMPARE_LTE_WHEN_LT_state: begin
        a = 1'h1;
        b = 2'h2;
        alufn = 6'h37;
        ans = 1'h1;
      end
      COMPARE_LTE_WHEN_GT_state: begin
        a = 2'h2;
        b = 1'h1;
        alufn = 6'h37;
        ans = 1'h0;
      end
      PAUSE_AND_ENABLE_MANUAL_INPUT_state: begin
        a = M_prev_a_q;
        b = M_prev_b_q;
        alufn = M_prev_alufn_q;
        ans = M_saved_ans_q;
        final_alu_out = M_alu_out;
        if (write_enable) begin
          
          case (select)
            2'h0: begin
              M_prev_a_d = man_input;
            end
            2'h1: begin
              M_prev_b_d = man_input;
            end
            2'h2: begin
              M_prev_alufn_d = man_input[0+5-:6];
            end
            2'h3: begin
              final_alu_out = M_prev_alu_out_q ^ man_input;
            end
          endcase
        end
      end
      default: begin
        a = 1'h0;
        b = 1'h0;
        alufn = 1'h0;
        ans = 16'hfaaf;
      end
    endcase
    if (M_state_q != PAUSE_AND_ENABLE_MANUAL_INPUT_state) begin
      M_saved_state_d = M_state_q;
      M_saved_ans_d = ans;
      final_alu_out = M_alu_out;
      M_prev_a_d = a;
      M_prev_b_d = b;
      M_prev_alufn_d = alufn;
      M_prev_alu_out_d = M_alu_out;
    end
    if (M_state_q == SUCCESS_state | M_state_q == PAUSE_AND_ENABLE_MANUAL_INPUT_state) begin
      M_state_d = M_state_q;
    end else begin
      if (M_state_q > PAUSE_AND_ENABLE_MANUAL_INPUT_state) begin
        M_state_d = 1'h0;
      end else begin
        M_state_d = M_state_q + 1'h1;
      end
    end
    if (final_alu_out == ans) begin
      out = M_state_q;
      error_is_happening = 1'h0;
    end else begin
      out = 8'h80 + M_state_q;
      error_is_happening = 1'h1;
    end
    if (M_state_q == SUCCESS_state) begin
      out = 8'haa;
    end
    if (M_state_q == PAUSE_AND_ENABLE_MANUAL_INPUT_state) begin
      out = M_saved_state_q;
    end
    if (man_reset) begin
      M_state_d = 1'h0;
    end
    if (pause) begin
      M_state_d = PAUSE_AND_ENABLE_MANUAL_INPUT_state;
    end
    display = 1'h0;
    if (M_state_q != PAUSE_AND_ENABLE_MANUAL_INPUT_state) begin
      
      case (select)
        2'h0: begin
          display = a;
        end
        2'h1: begin
          display = b;
        end
        2'h2: begin
          display = alufn;
        end
        2'h3: begin
          display = final_alu_out;
        end
      endcase
    end else begin
      
      case (select)
        2'h0: begin
          display = M_prev_a_q;
        end
        2'h1: begin
          display = M_prev_b_q;
        end
        2'h2: begin
          display = M_prev_alufn_q;
        end
        2'h3: begin
          display = final_alu_out;
        end
      endcase
    end
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_prev_a_q <= 1'h0;
      M_prev_b_q <= 1'h0;
      M_prev_alufn_q <= 1'h0;
      M_prev_alu_out_q <= 1'h0;
      M_saved_ans_q <= 1'h0;
      M_saved_state_q <= 1'h0;
    end else begin
      M_prev_a_q <= M_prev_a_d;
      M_prev_b_q <= M_prev_b_d;
      M_prev_alufn_q <= M_prev_alufn_d;
      M_prev_alu_out_q <= M_prev_alu_out_d;
      M_saved_ans_q <= M_saved_ans_d;
      M_saved_state_q <= M_saved_state_d;
    end
  end
  
  
  always @(posedge M_slowclock_value) begin
    if (rst == 1'b1) begin
      M_state_q <= 1'h0;
    end else begin
      M_state_q <= M_state_d;
    end
  end
  
endmodule
